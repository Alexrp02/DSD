// Autogenerated by Thrift Compiler (0.20.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#[allow(dead_code)]
#[allow(unused_imports)]
#[allow(unused_extern_crates)]
#[allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#[cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::protocol::{
    TFieldIdentifier, TInputProtocol, TListIdentifier, TMapIdentifier, TMessageIdentifier,
    TMessageType, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType,
};
use thrift::server::TProcessor;
use thrift::OrderedFloat;
use thrift::{
    ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient,
};

//
// CalculadoraCompleja service client
//

pub trait TCalculadoraComplejaSyncClient {
    fn sumar_vectores(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
    fn restar_vectores(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
    fn producto_escalar(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
    fn producto_vectorial(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
}

pub trait TCalculadoraComplejaSyncClientMarker {}

pub struct CalculadoraComplejaSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
    _i_prot: IP,
    _o_prot: OP,
    _sequence_number: i32,
}

impl<IP, OP> CalculadoraComplejaSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
    pub fn new(input_protocol: IP, output_protocol: OP) -> CalculadoraComplejaSyncClient<IP, OP> {
        CalculadoraComplejaSyncClient {
            _i_prot: input_protocol,
            _o_prot: output_protocol,
            _sequence_number: 0,
        }
    }
}

impl<IP, OP> TThriftClient for CalculadoraComplejaSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
    fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol {
        &mut self._i_prot
    }
    fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol {
        &mut self._o_prot
    }
    fn sequence_number(&self) -> i32 {
        self._sequence_number
    }
    fn increment_sequence_number(&mut self) -> i32 {
        self._sequence_number += 1;
        self._sequence_number
    }
}

impl<IP, OP> TCalculadoraComplejaSyncClientMarker for CalculadoraComplejaSyncClient<IP, OP>
where
    IP: TInputProtocol,
    OP: TOutputProtocol,
{
}

impl<C: TThriftClient + TCalculadoraComplejaSyncClientMarker> TCalculadoraComplejaSyncClient for C {
    fn sumar_vectores(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        ({
            self.increment_sequence_number();
            let message_ident = TMessageIdentifier::new(
                "sumarVectores",
                TMessageType::Call,
                self.sequence_number(),
            );
            let call_args = CalculadoraComplejaSumarVectoresArgs { vec1, vec2 };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("sumarVectores", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result =
                CalculadoraComplejaSumarVectoresResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn restar_vectores(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        ({
            self.increment_sequence_number();
            let message_ident = TMessageIdentifier::new(
                "restarVectores",
                TMessageType::Call,
                self.sequence_number(),
            );
            let call_args = CalculadoraComplejaRestarVectoresArgs { vec1, vec2 };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("restarVectores", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result =
                CalculadoraComplejaRestarVectoresResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn producto_escalar(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        ({
            self.increment_sequence_number();
            let message_ident = TMessageIdentifier::new(
                "productoEscalar",
                TMessageType::Call,
                self.sequence_number(),
            );
            let call_args = CalculadoraComplejaProductoEscalarArgs { vec1, vec2 };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("productoEscalar", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result =
                CalculadoraComplejaProductoEscalarResult::read_from_in_protocol(self.i_prot_mut())?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
    fn producto_vectorial(
        &mut self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        ({
            self.increment_sequence_number();
            let message_ident = TMessageIdentifier::new(
                "productoVectorial",
                TMessageType::Call,
                self.sequence_number(),
            );
            let call_args = CalculadoraComplejaProductoVectorialArgs { vec1, vec2 };
            self.o_prot_mut().write_message_begin(&message_ident)?;
            call_args.write_to_out_protocol(self.o_prot_mut())?;
            self.o_prot_mut().write_message_end()?;
            self.o_prot_mut().flush()
        })?;
        {
            let message_ident = self.i_prot_mut().read_message_begin()?;
            verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
            verify_expected_service_call("productoVectorial", &message_ident.name)?;
            if message_ident.message_type == TMessageType::Exception {
                let remote_error =
                    thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
                self.i_prot_mut().read_message_end()?;
                return Err(thrift::Error::Application(remote_error));
            }
            verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
            let result = CalculadoraComplejaProductoVectorialResult::read_from_in_protocol(
                self.i_prot_mut(),
            )?;
            self.i_prot_mut().read_message_end()?;
            result.ok_or()
        }
    }
}

//
// CalculadoraCompleja service processor
//

pub trait CalculadoraComplejaSyncHandler {
    fn handle_sumar_vectores(
        &self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
    fn handle_restar_vectores(
        &self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
    fn handle_producto_escalar(
        &self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
    fn handle_producto_vectorial(
        &self,
        vec1: Vec<OrderedFloat<f64>>,
        vec2: Vec<OrderedFloat<f64>>,
    ) -> thrift::Result<Vec<OrderedFloat<f64>>>;
}

pub struct CalculadoraComplejaSyncProcessor<H: CalculadoraComplejaSyncHandler> {
    handler: H,
}

impl<H: CalculadoraComplejaSyncHandler> CalculadoraComplejaSyncProcessor<H> {
    pub fn new(handler: H) -> CalculadoraComplejaSyncProcessor<H> {
        CalculadoraComplejaSyncProcessor { handler }
    }
    fn process_sumar_vectores(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCalculadoraComplejaProcessFunctions::process_sumar_vectores(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_restar_vectores(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCalculadoraComplejaProcessFunctions::process_restar_vectores(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_producto_escalar(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCalculadoraComplejaProcessFunctions::process_producto_escalar(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
    fn process_producto_vectorial(
        &self,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        TCalculadoraComplejaProcessFunctions::process_producto_vectorial(
            &self.handler,
            incoming_sequence_number,
            i_prot,
            o_prot,
        )
    }
}

pub struct TCalculadoraComplejaProcessFunctions;

impl TCalculadoraComplejaProcessFunctions {
    pub fn process_sumar_vectores<H: CalculadoraComplejaSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CalculadoraComplejaSumarVectoresArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_sumar_vectores(args.vec1, args.vec2) {
            Ok(handler_return) => {
                let message_ident = TMessageIdentifier::new(
                    "sumarVectores",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CalculadoraComplejaSumarVectoresResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "sumarVectores",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        { ApplicationError::new(ApplicationErrorKind::Unknown, e.to_string()) };
                    let message_ident = TMessageIdentifier::new(
                        "sumarVectores",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_restar_vectores<H: CalculadoraComplejaSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CalculadoraComplejaRestarVectoresArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_restar_vectores(args.vec1, args.vec2) {
            Ok(handler_return) => {
                let message_ident = TMessageIdentifier::new(
                    "restarVectores",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CalculadoraComplejaRestarVectoresResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "restarVectores",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        { ApplicationError::new(ApplicationErrorKind::Unknown, e.to_string()) };
                    let message_ident = TMessageIdentifier::new(
                        "restarVectores",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_producto_escalar<H: CalculadoraComplejaSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CalculadoraComplejaProductoEscalarArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_producto_escalar(args.vec1, args.vec2) {
            Ok(handler_return) => {
                let message_ident = TMessageIdentifier::new(
                    "productoEscalar",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CalculadoraComplejaProductoEscalarResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "productoEscalar",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        { ApplicationError::new(ApplicationErrorKind::Unknown, e.to_string()) };
                    let message_ident = TMessageIdentifier::new(
                        "productoEscalar",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
    pub fn process_producto_vectorial<H: CalculadoraComplejaSyncHandler>(
        handler: &H,
        incoming_sequence_number: i32,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let args = CalculadoraComplejaProductoVectorialArgs::read_from_in_protocol(i_prot)?;
        match handler.handle_producto_vectorial(args.vec1, args.vec2) {
            Ok(handler_return) => {
                let message_ident = TMessageIdentifier::new(
                    "productoVectorial",
                    TMessageType::Reply,
                    incoming_sequence_number,
                );
                o_prot.write_message_begin(&message_ident)?;
                let ret = CalculadoraComplejaProductoVectorialResult {
                    result_value: Some(handler_return),
                };
                ret.write_to_out_protocol(o_prot)?;
                o_prot.write_message_end()?;
                o_prot.flush()
            }
            Err(e) => match e {
                thrift::Error::Application(app_err) => {
                    let message_ident = TMessageIdentifier::new(
                        "productoVectorial",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
                _ => {
                    let ret_err =
                        { ApplicationError::new(ApplicationErrorKind::Unknown, e.to_string()) };
                    let message_ident = TMessageIdentifier::new(
                        "productoVectorial",
                        TMessageType::Exception,
                        incoming_sequence_number,
                    );
                    o_prot.write_message_begin(&message_ident)?;
                    thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
                    o_prot.write_message_end()?;
                    o_prot.flush()
                }
            },
        }
    }
}

impl<H: CalculadoraComplejaSyncHandler> TProcessor for CalculadoraComplejaSyncProcessor<H> {
    fn process(
        &self,
        i_prot: &mut dyn TInputProtocol,
        o_prot: &mut dyn TOutputProtocol,
    ) -> thrift::Result<()> {
        let message_ident = i_prot.read_message_begin()?;
        let res = match &*message_ident.name {
            "sumarVectores" => {
                self.process_sumar_vectores(message_ident.sequence_number, i_prot, o_prot)
            }
            "restarVectores" => {
                self.process_restar_vectores(message_ident.sequence_number, i_prot, o_prot)
            }
            "productoEscalar" => {
                self.process_producto_escalar(message_ident.sequence_number, i_prot, o_prot)
            }
            "productoVectorial" => {
                self.process_producto_vectorial(message_ident.sequence_number, i_prot, o_prot)
            }
            method => Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::UnknownMethod,
                format!("unknown method {}", method),
            ))),
        };
        thrift::server::handle_process_result(&message_ident, res, o_prot)
    }
}

//
// CalculadoraComplejaSumarVectoresArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaSumarVectoresArgs {
    vec1: Vec<OrderedFloat<f64>>,
    vec2: Vec<OrderedFloat<f64>>,
}

impl CalculadoraComplejaSumarVectoresArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaSumarVectoresArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<Vec<OrderedFloat<f64>>> = None;
        let mut f_2: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_0 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_0);
                    }
                    i_prot.read_list_end()?;
                    f_1 = Some(val);
                }
                2 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_1 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_1);
                    }
                    i_prot.read_list_end()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CalculadoraComplejaSumarVectoresArgs.vec1", &f_1)?;
        verify_required_field_exists("CalculadoraComplejaSumarVectoresArgs.vec2", &f_2)?;
        let ret = CalculadoraComplejaSumarVectoresArgs {
            vec1: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            vec2: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("sumarVectores_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec1", TType::List, 1))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec1.len() as i32))?;
        for e in &self.vec1 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec2", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec2.len() as i32))?;
        for e in &self.vec2 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaSumarVectoresResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaSumarVectoresResult {
    result_value: Option<Vec<OrderedFloat<f64>>>,
}

impl CalculadoraComplejaSumarVectoresResult {
    fn ok_or(self) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CalculadoraComplejaSumarVectores",
            )))
        }
    }
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaSumarVectoresResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_2 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_2);
                    }
                    i_prot.read_list_end()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CalculadoraComplejaSumarVectoresResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CalculadoraComplejaSumarVectoresResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
            for e in fld_var {
                o_prot.write_double((*e).into())?;
            }
            o_prot.write_list_end()?;
            o_prot.write_field_end()?
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaRestarVectoresArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaRestarVectoresArgs {
    vec1: Vec<OrderedFloat<f64>>,
    vec2: Vec<OrderedFloat<f64>>,
}

impl CalculadoraComplejaRestarVectoresArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaRestarVectoresArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<Vec<OrderedFloat<f64>>> = None;
        let mut f_2: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_3 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_3);
                    }
                    i_prot.read_list_end()?;
                    f_1 = Some(val);
                }
                2 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_4 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_4);
                    }
                    i_prot.read_list_end()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CalculadoraComplejaRestarVectoresArgs.vec1", &f_1)?;
        verify_required_field_exists("CalculadoraComplejaRestarVectoresArgs.vec2", &f_2)?;
        let ret = CalculadoraComplejaRestarVectoresArgs {
            vec1: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            vec2: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("restarVectores_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec1", TType::List, 1))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec1.len() as i32))?;
        for e in &self.vec1 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec2", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec2.len() as i32))?;
        for e in &self.vec2 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaRestarVectoresResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaRestarVectoresResult {
    result_value: Option<Vec<OrderedFloat<f64>>>,
}

impl CalculadoraComplejaRestarVectoresResult {
    fn ok_or(self) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CalculadoraComplejaRestarVectores",
            )))
        }
    }
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaRestarVectoresResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_5 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_5);
                    }
                    i_prot.read_list_end()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CalculadoraComplejaRestarVectoresResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CalculadoraComplejaRestarVectoresResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
            for e in fld_var {
                o_prot.write_double((*e).into())?;
            }
            o_prot.write_list_end()?;
            o_prot.write_field_end()?
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaProductoEscalarArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaProductoEscalarArgs {
    vec1: Vec<OrderedFloat<f64>>,
    vec2: Vec<OrderedFloat<f64>>,
}

impl CalculadoraComplejaProductoEscalarArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaProductoEscalarArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<Vec<OrderedFloat<f64>>> = None;
        let mut f_2: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_6 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_6);
                    }
                    i_prot.read_list_end()?;
                    f_1 = Some(val);
                }
                2 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_7 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_7);
                    }
                    i_prot.read_list_end()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CalculadoraComplejaProductoEscalarArgs.vec1", &f_1)?;
        verify_required_field_exists("CalculadoraComplejaProductoEscalarArgs.vec2", &f_2)?;
        let ret = CalculadoraComplejaProductoEscalarArgs {
            vec1: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            vec2: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("productoEscalar_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec1", TType::List, 1))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec1.len() as i32))?;
        for e in &self.vec1 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec2", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec2.len() as i32))?;
        for e in &self.vec2 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaProductoEscalarResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaProductoEscalarResult {
    result_value: Option<Vec<OrderedFloat<f64>>>,
}

impl CalculadoraComplejaProductoEscalarResult {
    fn ok_or(self) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CalculadoraComplejaProductoEscalar",
            )))
        }
    }
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaProductoEscalarResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_8 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_8);
                    }
                    i_prot.read_list_end()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CalculadoraComplejaProductoEscalarResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CalculadoraComplejaProductoEscalarResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
            for e in fld_var {
                o_prot.write_double((*e).into())?;
            }
            o_prot.write_list_end()?;
            o_prot.write_field_end()?
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaProductoVectorialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaProductoVectorialArgs {
    vec1: Vec<OrderedFloat<f64>>,
    vec2: Vec<OrderedFloat<f64>>,
}

impl CalculadoraComplejaProductoVectorialArgs {
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaProductoVectorialArgs> {
        i_prot.read_struct_begin()?;
        let mut f_1: Option<Vec<OrderedFloat<f64>>> = None;
        let mut f_2: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                1 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_9 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_9);
                    }
                    i_prot.read_list_end()?;
                    f_1 = Some(val);
                }
                2 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_10 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_10);
                    }
                    i_prot.read_list_end()?;
                    f_2 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        verify_required_field_exists("CalculadoraComplejaProductoVectorialArgs.vec1", &f_1)?;
        verify_required_field_exists("CalculadoraComplejaProductoVectorialArgs.vec2", &f_2)?;
        let ret = CalculadoraComplejaProductoVectorialArgs {
            vec1: f_1
                .expect("auto-generated code should have checked for presence of required fields"),
            vec2: f_2
                .expect("auto-generated code should have checked for presence of required fields"),
        };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("productoVectorial_args");
        o_prot.write_struct_begin(&struct_ident)?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec1", TType::List, 1))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec1.len() as i32))?;
        for e in &self.vec1 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_begin(&TFieldIdentifier::new("vec2", TType::List, 2))?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Double, self.vec2.len() as i32))?;
        for e in &self.vec2 {
            o_prot.write_double((*e).into())?;
        }
        o_prot.write_list_end()?;
        o_prot.write_field_end()?;
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}

//
// CalculadoraComplejaProductoVectorialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct CalculadoraComplejaProductoVectorialResult {
    result_value: Option<Vec<OrderedFloat<f64>>>,
}

impl CalculadoraComplejaProductoVectorialResult {
    fn ok_or(self) -> thrift::Result<Vec<OrderedFloat<f64>>> {
        if self.result_value.is_some() {
            Ok(self.result_value.unwrap())
        } else {
            Err(thrift::Error::Application(ApplicationError::new(
                ApplicationErrorKind::MissingResult,
                "no result received for CalculadoraComplejaProductoVectorial",
            )))
        }
    }
    fn read_from_in_protocol(
        i_prot: &mut dyn TInputProtocol,
    ) -> thrift::Result<CalculadoraComplejaProductoVectorialResult> {
        i_prot.read_struct_begin()?;
        let mut f_0: Option<Vec<OrderedFloat<f64>>> = None;
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                0 => {
                    let list_ident = i_prot.read_list_begin()?;
                    let mut val: Vec<OrderedFloat<f64>> =
                        Vec::with_capacity(list_ident.size as usize);
                    for _ in 0..list_ident.size {
                        let list_elem_11 = OrderedFloat::from(i_prot.read_double()?);
                        val.push(list_elem_11);
                    }
                    i_prot.read_list_end()?;
                    f_0 = Some(val);
                }
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                }
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
        let ret = CalculadoraComplejaProductoVectorialResult { result_value: f_0 };
        Ok(ret)
    }
    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
        let struct_ident = TStructIdentifier::new("CalculadoraComplejaProductoVectorialResult");
        o_prot.write_struct_begin(&struct_ident)?;
        if let Some(ref fld_var) = self.result_value {
            o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
            o_prot.write_list_begin(&TListIdentifier::new(TType::Double, fld_var.len() as i32))?;
            for e in fld_var {
                o_prot.write_double((*e).into())?;
            }
            o_prot.write_list_end()?;
            o_prot.write_field_end()?
        }
        o_prot.write_field_stop()?;
        o_prot.write_struct_end()
    }
}
